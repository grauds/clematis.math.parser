/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
package org.clematis.math.parsers.string;

import org.clematis.math.IExpressionItem;
import org.clematis.math.parsers.string.Node;
import org.clematis.math.parsers.string.StringMathParserTreeConstants;
import org.clematis.math.v1.Constant;
import org.clematis.math.v1.StringConstant;
import org.clematis.math.v1.Variable;
import org.clematis.math.v1.algorithm.SimpleParameter;
import org.clematis.math.v1.functions.FunctionReference;
import org.clematis.math.v1.operations.Addition;
import org.clematis.math.v1.operations.Multiplication;
import org.clematis.math.v1.operations.Power;
import org.clematis.math.v1.operations.SimpleFraction;
import org.clematis.math.v1.operations.Substraction;
import org.clematis.math.v1.operations.Unary;

import lombok.Getter;
import lombok.Setter;
/**
 * Node class derived from stub, generated by JavaCC. This is a basic node for maths
 * expression tree. It holds reference to parent and children nodes.
 */
@Getter
@Setter
public class SimpleNode implements Node {
    /**
     * Parent node, it is also a calculable expression item
     */
    protected Node parent = null;
    /**
     * Node's children, it is also calculable expression items
     */
    protected Node[] children = null;
    /**
     * Name of this node from javacc token
     */
    protected String name = null;
    /**
     * Modifier for this node
     */
    protected int kind = -1;
    /**
     * Ident from parser grammar
     */
    protected int id = 0;
    /**
     * Embedded expression item
     */
    protected IExpressionItem expressionItem;

    /**
     * Empty public constructor
     */
    public SimpleNode() {
    }

    /**
     * Constructor with ident, used by javacc parser
     *
     * @param i ident, used by javacc parser
     */
    public SimpleNode(int i) {
        id = i;
    }

    /**
     * Shallow copy constructor. This does not copy parent and children nodes.
     *
     * @param node to copy
     */
    public SimpleNode(SimpleNode node) {
        this.id = node.id;
        this.kind = node.kind;
        this.name = node.name;
    }

    public int getTokenKind() {
        return kind;
    }

    public void setTokenKind(int kind) {
        this.kind = kind;
    }

    public static Node jjtCreate(StringMathParser parser, int id) {

        SimpleNode result = new SimpleNode(id);
        IExpressionItem expressionItem = null;

        switch (id) {
            case StringMathParserTreeConstants.JJTVOID:
            case StringMathParserTreeConstants.JJTEXPR:
            case StringMathParserTreeConstants.JJTVECTOR_EXPR:
            case StringMathParserTreeConstants.JJTINDEX_EXPR:
            case StringMathParserTreeConstants.JJTEQUALS_EXPR:
                break;
            case StringMathParserTreeConstants.JJTPLUS_EXPR: {
                expressionItem = new Addition();
            }
            case StringMathParserTreeConstants.JJTMINUS_EXPR: {
                expressionItem = new Substraction();
            }
            case StringMathParserTreeConstants.JJTMULT_EXPR: {
                expressionItem = new Multiplication();
            }
            case StringMathParserTreeConstants.JJTDIV_EXPR: {
                expressionItem = new SimpleFraction();
            }
            case StringMathParserTreeConstants.JJTUNARY_MINUS: {
                Unary unary = new Unary();
                unary.setKind(Unary.MINUS);
                expressionItem = unary;
            }
            case StringMathParserTreeConstants.JJTUNARY_PLUS: {
                Unary unary = new Unary();
                unary.setKind(Unary.PLUS);
                expressionItem = unary;
            }
            case StringMathParserTreeConstants.JJTPOWER_EXPR: {
                expressionItem = new Power();
            }
            case StringMathParserTreeConstants.JJTSTRING: {
                expressionItem = new StringConstant();
            }
            case StringMathParserTreeConstants.JJTVAR: {
              //  expressionItem = new SimpleParameter();
            }
            case StringMathParserTreeConstants.JJTNUMBER: {
                expressionItem = new Constant();
            }
            case StringMathParserTreeConstants.JJTIDENTIFIER: {
                expressionItem = new Variable();
            }
            case StringMathParserTreeConstants.JJTCONSTANT: {
                expressionItem = new Constant();
            }
            case StringMathParserTreeConstants.JJTDELTA_EXPR: {
                expressionItem = new StringConstant();
            }
            case StringMathParserTreeConstants.JJTHAT_EXPR: {
                expressionItem = new StringConstant();
            }
            case StringMathParserTreeConstants.JJTFUNCTION: {
                expressionItem = new FunctionReference(parser.getFunctionProvider());
            }
            default:

        }
        result.setExpressionItem(expressionItem);
        return result;

    }


    public void jjtOpen() {
        // does nothing for now
    }

    public void jjtClose() {
        // does nothing for now
    }

    public void jjtSetParent(Node n) {
        parent = n;
    }

    public Node jjtGetParent() {
        return parent;
    }

    public void jjtAddChild(Node n, int i) {
        if (getChildren() == null) {
            children = new Node[i + 1];
        } else if (i >= getChildren().length) {
            Node[] c = new Node[i + 1];
            System.arraycopy(getChildren(), 0, c, 0, getChildren().length);
            children = c;
        }
        getChildren()[i] = n;
    }

    public Node jjtGetChild(int i) {
        return getChildren()[i];
    }

    public int jjtGetNumChildren() {
        return (getChildren() == null) ? 0 : getChildren().length;
    }

    public String toString() {
        return getName();
    }

    public String toString(String prefix) {
        return prefix + getClass() + " : " + this;
    }

    /**
     * Dump this node along with its children to text tree to standard output stream
     */
    @SuppressWarnings("checkstyle:Regexp")
    public void dump(String prefix) {
        System.out.println(toString(prefix));
        if (getChildren() != null) {
            for (int i = 0; i < getChildren().length; ++i) {
                Node n = getChildren()[i];
                if (n != null) {
                    n.dump(prefix + " ");
                }
            }
        }
    }

}


