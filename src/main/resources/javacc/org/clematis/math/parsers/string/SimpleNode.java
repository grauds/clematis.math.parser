/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
package org.clematis.math.parsers.string;


import java.util.ArrayList;
import java.util.List;

import org.clematis.math.IExpressionItem;
import org.clematis.math.v1.Constant;
import org.clematis.math.v1.IFunction;
import org.clematis.math.v1.SimpleValue;
import org.clematis.math.v1.StringConstant;
import org.clematis.math.v1.Variable;
import org.clematis.math.v1.algorithm.ParameterReference;
import org.clematis.math.v1.functions.FunctionReference;
import org.clematis.math.v1.operations.Addition;
import org.clematis.math.v1.operations.Expression;
import org.clematis.math.v1.operations.Multiplication;
import org.clematis.math.v1.operations.Power;
import org.clematis.math.v1.operations.SimpleFraction;
import org.clematis.math.v1.operations.Substraction;
import org.clematis.math.v1.operations.Unary;

import lombok.Getter;
import lombok.Setter;
/**
 * Node class derived from stub, generated by JavaCC. This is a basic node for maths
 * expression tree. It holds reference to parent and children nodes.
 */
@Getter
@Setter
public class SimpleNode implements Node {
    /**
     * Parent node, it is also a calculable expression item
     */
    protected Node parent = null;
    /**
     * Node's children, it is also calculable expression items
     */
    protected final List<Node> children = new ArrayList<>();
    /**
     * Name of this node from javacc token
     */
    protected String name = null;
    /**
     * Modifier for this node
     */
    protected int kind = -1;
    /**
     * Ident from parser grammar
     */
    protected int id = 0;
    /**
     * Embedded expression item
     */
    protected IExpressionItem expressionItem;

    /**
     * Empty public constructor
     */
    public SimpleNode() {
    }

    /**
     * Constructor with ident, used by javacc parser
     *
     * @param i ident, used by javacc parser
     */
    public SimpleNode(int i) {
        id = i;
    }

    /**
     * Shallow copy constructor. This does not copy parent and children nodes.
     *
     * @param node to copy
     */
    public SimpleNode(SimpleNode node) {
        this.id = node.id;
        this.kind = node.kind;
        this.name = node.name;
    }

    public void setName(String name) {
        this.name = name;
        if (this.expressionItem instanceof SimpleValue) {
            ((SimpleValue) this.expressionItem).setValue(name);
        } else if (this.expressionItem instanceof IFunction) {
            ((IFunction) this.expressionItem).setSignature(name);
        }
    }

    public int getTokenKind() {
        return kind;
    }

    public void setTokenKind(int kind) {
        this.kind = kind;
    }

    public static Node jjtCreate(StringMathParser parser, int id) {

        SimpleNode result = new SimpleNode(id);
        IExpressionItem expressionItem = null;

        switch (id) {
            case StringMathParserTreeConstants.JJTVOID:
            case StringMathParserTreeConstants.JJTEXPR:
            case StringMathParserTreeConstants.JJTVECTOR_EXPR:
            case StringMathParserTreeConstants.JJTINDEX_EXPR:
            case StringMathParserTreeConstants.JJTEQUALS_EXPR:
                expressionItem = new Expression();
                break;
            case StringMathParserTreeConstants.JJTPLUS_EXPR: {
                expressionItem = new Addition();
                break;
            }
            case StringMathParserTreeConstants.JJTMINUS_EXPR: {
                expressionItem = new Substraction();
                break;
            }
            case StringMathParserTreeConstants.JJTMULT_EXPR: {
                expressionItem = new Multiplication();
                break;
            }
            case StringMathParserTreeConstants.JJTDIV_EXPR: {
                expressionItem = new SimpleFraction();
                break;
            }
            case StringMathParserTreeConstants.JJTUNARY_MINUS: {
                Unary unary = new Unary();
                unary.setKind(Unary.MINUS);
                expressionItem = unary;
                break;
            }
            case StringMathParserTreeConstants.JJTUNARY_PLUS: {
                Unary unary = new Unary();
                unary.setKind(Unary.PLUS);
                expressionItem = unary;
                break;
            }
            case StringMathParserTreeConstants.JJTPOWER_EXPR: {
                expressionItem = new Power();
                break;
            }
            case StringMathParserTreeConstants.JJTSTRING: {
                expressionItem = new StringConstant();
                break;
            }
            case StringMathParserTreeConstants.JJTVAR: {
                expressionItem = new ParameterReference();
                break;
            }
            case StringMathParserTreeConstants.JJTNUMBER: {
                expressionItem = new Constant();
                break;
            }
            case StringMathParserTreeConstants.JJTIDENTIFIER: {
                expressionItem = new Variable();
                break;
            }
            case StringMathParserTreeConstants.JJTCONSTANT: {
                expressionItem = new Constant();
                break;
            }
            case StringMathParserTreeConstants.JJTDELTA_EXPR: {
                expressionItem = new StringConstant();
                break;
            }
            case StringMathParserTreeConstants.JJTHAT_EXPR: {
                expressionItem = new StringConstant();
                break;
            }
            case StringMathParserTreeConstants.JJTFUNCTION: {
                expressionItem = new FunctionReference(parser.getFunctionProvider());
                break;
            }
            default:

        }
        result.setExpressionItem(expressionItem);
        return result;

    }


    public void jjtOpen() {
        // does nothing for now
    }

    public void jjtClose() {
        // does nothing for now
    }

    public void jjtSetParent(Node n) {
        parent = n;
    }

    public Node jjtGetParent() {
        return parent;
    }

    public void jjtAddChild(Node n, int i) {
        if (this.children.size() <= i) {
            ((ArrayList<?>) this.children).ensureCapacity(i + 1);
            while (this.children.size() <= i) {
                this.children.add(null);
            }
        }
        this.children.set(i, n);
        if (this.expressionItem != null) {
            this.expressionItem.setArgument(n.getExpressionItem(), i);
        }
    }

    public Node jjtGetChild(int i) {
        return this.children.get(i);
    }

    public int jjtGetNumChildren() {
        return (getChildren() == null) ? 0 : getChildren().size();
    }

    public String toString() {
        return getName();
    }

    public String toString(String prefix) {
        return prefix + getClass() + " : " + this;
    }

    /**
     * Dump this node along with its children to text tree to standard output stream
     */
    @SuppressWarnings("checkstyle:Regexp")
    public void dump(String prefix) {
        System.out.println(toString(prefix));
        if (getChildren() != null) {
            for (Node n : this.children) {
                if (n != null) {
                    n.dump(prefix + " ");
                }
            }
        }
    }

    public IExpressionItem getExpressionItem() {
        return this.expressionItem;
    }

}


