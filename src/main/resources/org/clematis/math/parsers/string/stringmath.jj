/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\stringmath.jj */
/*@egen*//***************************************************************
String Mathematics Parser Grammar

@author Anton Troshin
***************************************************************/
options
{                                                                                                              
    STATIC = false;
    USER_CHAR_STREAM = false;
    USER_TOKEN_MANAGER = false;
    FORCE_LA_CHECK=true;                                                                                                            
}
PARSER_BEGIN(StringMathParser)

package org.clematis.math.parsers.string;

/***************************************************************
String Mathematics Parser

This parser built on grammar with following features.

The precedence of operators is very important. Since this is a
recursive descent parser, it is easy to see which operators have
higher order of precedence. The following table outlines the
order incorporated in this grammar.

Order of precedence (from lowest to highest):

   +   -            addition, subtraction
   *   /            multiplication, division
   +   -            unary +/-
   ^                power

Parser supports injection of variable parameters into string maths,
annotated with $ sign. Parameters may be of following types:

  $a, $a_j12, $acv, ${acv}

Two last parameter notations are eqivalent, in fact it is not reflected
by the grammar, but by evaluation procedure.

Simple variable may be of only one letter: x, y, z, a, b, c.

Variables and expressions may have indexes: x_2, y_i, z_(k), z_(betta).
If index contains only one letter it may not have brackets.

@author Anton Troshin
***************************************************************/
import java.io.StringReader;
import org.clematis.math.*;
import org.clematis.math.parsers.*;
import org.clematis.math.algorithm.*;
/**
 * Class for parsing calculator notation maths.
 */
public class StringMathParser/*@bgen(jjtree)*/implements StringMathParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTStringMathParserState jjtree = new JJTStringMathParserState();

/*@egen*/
     /**
      * Instance of parameter provider
      */
     private iSimpleParameterProvider parameterProvider = null;
     /**
      * Instance of variable provider
      */
     private iVariableProvider variableProvider = null;
     /**
      * Instance of function provider
      */
     private iFunctionProvider functionProvider = new FunctionFactory(); 
     /**
      * Parse expression and print to webtex
      */
     public static String printToWebTex(String expr)throws ParseException
     {
        StringMathParser parser = new StringMathParser(new StringReader(expr));
        SimpleNode n = parser.Start();
        StringBuilder sb = new StringBuilder();
        WebTexPrinter.print(n, sb);
        return sb.toString();
     }
     /**
      * Return an instance of parameter provider
      */
     public iSimpleParameterProvider getParameterProvider()
     {
         return parameterProvider;
     }
     /**
      * Sets an instance of parameter provider parser
      */
     public void setParameterProvider(iSimpleParameterProvider parameterProvider)
     {
         this.parameterProvider = parameterProvider;
     }
     /**
      * Return an instance of variable provider
      */
     public iVariableProvider getVariableProvider()
     {
         return variableProvider;
     }
     /**
      * Sets an instance of variable provider parser
      */
     public void setVariableProvider(iVariableProvider variableProvider)
     {
         this.variableProvider = variableProvider;
     }
     /**
      * Return an instance of function provider
      */
     public iFunctionProvider getFunctionProvider()
     {
         return functionProvider;
     }
     /**
      * Sets an instance of function provider parser
      */
     public void setFunctionProvider(iFunctionProvider functionProvider)
     {
         this.functionProvider = functionProvider;
     }
     /**
      * Returns true if one next token is a function name
      */
     public boolean isFunctionAhead()
     {
     	StringBuffer buffer = new StringBuffer();
     	int i = 1;
     	if ( getToken(1).kind == IDENTIFIER || getToken(1).kind == EXP_E )
     	{
            while ( getToken(i).kind == IDENTIFIER ||
                    getToken(i).kind == NUMBER || getToken(i).kind == EXP_E )
            {
                buffer.append( getToken(i).image );
                i++;
                if ( functionProvider.hasFunction(buffer.toString()) )
                {
                    return true;
                }
            }
         }
        return false;
     }
}

PARSER_END(StringMathParser)

SKIP :
{
      " "
    | "\t"
    | "\n"
    | "\r"
    | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
    | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/" >
}

TOKEN :
{
      < NUMBER: <INTEGER> | <FLOAT> >
    |
      < #INTEGER: ["1"-"9"] (["0"-"9"])* >
    |
      < #FLOAT: //comment: (<INTEGER>)? "." <INTEGER>] (<EXPONENT>)?>
            (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
          | "." (["0"-"9"])+ (<EXPONENT>)?
          | (["0"-"9"])+ <EXPONENT>
          | (["0"-"9"])+ (<EXPONENT>)? >
     |
     < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
}

TOKEN :
{
  < IDENTIFIER:  <LETTER>  >
 |
  < #LETTER: ["a"-"d","f"-"z","A"-"Z"]
    | "\\alpha"
    | "\\beta"
    | "\\gamma"
    | "\\delta"
    | "\\epsilon"
    | "\\varepsilon"
    | "\\zeta"
    | "\\eta"
    | "\\theta"
    | "\\vartheta"
    | "\\iota"
    | "\\kappa"
    | "\\lambda"
    | "\\mu"
    | "\\nu"
    | "\\xi"
    | "\\varpi"
    | "\\rho"
    | "\\varrho"
    | "\\sigma"
    | "\\tau"
    | "\\upsilon"
    | "\\phi"
    | "\\varphi"
    | "\\chi"
    | "\\psi"
    | "\\omega"
    | "\\Delta"
    | "\\Gamma"
    | "\\Lambda"
    | "\\Omega"
    | "\\Phi"
    | "\\Pi"
    | "\\Psi"
    | "\\Sigma"
    | "\\Theta"
    | "\\Xi"
    | "\\Upsilon"
 >
}

TOKEN :
{
   < VARIABLE: 
            "$"
	           ("{")?
	              ( (<LETTER>|"e") ( (<LETTER>|"e") | <NUMBER> )*  (<UNDERLINE> ( (<LETTER>|"e") | <NUMBER> ))* )
	           ("}")?	    
   >	
|
   < STRING:
        "\""
         (   (~["\"","\\","\n","\r"])
             | ("\\" ( ["n","t","b","r","f","\\","'","\""]
                  | ["0"-"7"] ( ["0"-"7"] )?
                  | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                     )
               )
      )*
      "\""
  >	
|
   < EXP_E: "e" >
|
   < PI: "\\pi" | "pi" | "\\PI" | "PI" >
|
   < MULT: "*" | "\\times" | "\\cdot">
|
   < DIV: "/" | "\\div" >
|
   < PLUS: "+" >
|
   < MINUS: "-" >
|
   < EQUALS: "=" >
|
   < POWER: "^"  >
|
   < DELTA: "\\delt" | "delt"  >
|
   < HAT: "\\hat" | "hat" >
|
   < OPEN_BR: "(" | "[" | "{" >
|
   < CLOSE_BR: ")" | "]" | "}" >
|
   < UNDERLINE: "_"  >      
}

SimpleNode Start() : {}
{/*@bgen(jjtree) EXPR */
  {
    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (  Expression() <EOF>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001, true);
                          jjtc001 = false;
                        }
/*@egen*/ { return jjtn001; } )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/
  |  <EOF>
	{
		throw new ParseException("Empty expression");
		return null;
	}  
}

void Expression() : {}
{
    EqualsExpression()
}

void EqualsExpression()                  :
{/*@bgen(jjtree) #EQUALS_EXPR(> 1) */
    SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEQUALS_EXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    String name=null;
    Token t;
}
{/*@bgen(jjtree) #EQUALS_EXPR(> 1) */
  try {
/*@egen*/
  (
     PlusExpression() ( ( t=<EQUALS>{name=t.image;} ) PlusExpression() )*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    jjtc000 = false;
  }
/*@egen*/
  {
     jjtn000.setTokenName(name);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void PlusExpression()                 :
{/*@bgen(jjtree) #PLUS_EXPR(> 1) */
    SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTPLUS_EXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) #PLUS_EXPR(> 1) */
 try {
/*@egen*/
 (
    (MinusExpression() (  (( t=<PLUS>){jjtn000.setTokenName(t.image);} MinusExpression()))*)
 )/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
   }
 }
/*@egen*/
}

void MinusExpression()                  :
{/*@bgen(jjtree) #MINUS_EXPR(> 1) */
    SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTMINUS_EXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) #MINUS_EXPR(> 1) */
 try {
/*@egen*/
 (
    (MultExpression() (  (( t=<MINUS> ){jjtn000.setTokenName(t.image);} MultExpression()))*)
 )/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
   }
 }
/*@egen*/
}

void MultExpression()                 :
{/*@bgen(jjtree) #MULT_EXPR(> 1) */
    SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTMULT_EXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) #MULT_EXPR(> 1) */
 try {
/*@egen*/
 (
    DivExpressionMinus() ( ( t=<MULT> {jjtn000.setTokenName(t.image);}  DivExpressionMinus()) | {jjtn000.setTokenName("*");}DivExpression())*
 )/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
   }
 }
/*@egen*/
}

//divide expression without unary minus
void DivExpression()                :
{/*@bgen(jjtree) #DIV_EXPR(> 1) */
    SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTDIV_EXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) #DIV_EXPR(> 1) */
  try {
/*@egen*/
  (
     (PowerExpression() (  ( t=<DIV> ){jjtn000.setTokenName(t.image);} PowerExpression()) *)
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

//divide expression with unary minus
void DivExpressionMinus()                :
{/*@bgen(jjtree) #DIV_EXPR(> 1) */
    SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTDIV_EXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) #DIV_EXPR(> 1) */
  try {
/*@egen*/
  (
     (NegativeExpr() (  ( t=<DIV> ){jjtn000.setTokenName(t.image);} NegativeExpr()) *)
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void NegativeExpr() :
{
}
{/*@bgen(jjtree) UNARY_MINUS */
    {
      SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTUNARY_MINUS);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (<MINUS> PositiveExpr() )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/ | PositiveExpr()
}

void PositiveExpr() :
{
}
{/*@bgen(jjtree) UNARY_PLUS */
    {
      SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTUNARY_PLUS);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (<PLUS> PowerExpression() )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/ | PowerExpression()
}

void PowerExpression()                  :
{/*@bgen(jjtree) #POWER_EXPR(> 1) */
    SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTPOWER_EXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) #POWER_EXPR(> 1) */
   try {
/*@egen*/
   (
        IndexExpression() ( t=<POWER> {jjtn000.setTokenName(t.image);} IndexExpression() )*
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
     }
   }
/*@egen*/
}

void IndexExpression()                  :
{/*@bgen(jjtree) #INDEX_EXPR(> 1) */
    SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTINDEX_EXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) #INDEX_EXPR(> 1) */
   try {
/*@egen*/
   (
        UnaryExpression() ( t=<UNDERLINE> {jjtn000.setTokenName(t.image);} Index()  )*
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
     }
   }
/*@egen*/
}

void UnaryExpression() : {}
{
 (
 // this construction gives warning due to FORCE_LA_CHECK=true, though it works correctly
	( LOOKAHEAD( { isFunctionAhead() } )  Function()
		|
        Identifier()
        |
        Constant()     
	)
   | <OPEN_BR> Expression() <CLOSE_BR>
   | Variable()
   | Number()
   | VectorExpression()
   | DeltaExpression()
   | HatExpression()
   | String()
 )
}

void Index()       :
{/*@bgen(jjtree) INDEX */
    SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTINDEX);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
    StringBuffer index = new StringBuffer();
}
{/*@bgen(jjtree) INDEX */
 try {
/*@egen*/
 (
     <OPEN_BR>
          ( (t=<IDENTIFIER> | t=<NUMBER> | t=<EXP_E>) { index.append(t.image); } )+
          { jjtn000.setTokenName(index.toString()); }
     <CLOSE_BR>
   | Identifier()
   | Number()
   | Constant()
 )/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

Token String()         :
{/*@bgen(jjtree) STRING */
   SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSTRING);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
/*@egen*/
   Token t;
}
{/*@bgen(jjtree) STRING */
 try {
/*@egen*/
 (
   t=<STRING>
 )/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 {
   jjtn000.setTokenName(t.image);
   return t;
 }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

Token Variable()      :
{/*@bgen(jjtree) VAR */
   SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTVAR);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
/*@egen*/
   Token t;
}
{/*@bgen(jjtree) VAR */
 try {
/*@egen*/
 (
    (t= <VARIABLE>
        {
           /**
            * Provided name of variable parameter, we can search for constant
            * result in parameter provider
            */
           String name = t.image;
           if ( getParameterProvider() != null )
           {
               AbstractConstant constant = getParameterProvider().getParameterConstant(name);
               if ( constant != null && (jjtn000 instanceof SimpleParameter) )
               {
                   // set current result
                   ((SimpleParameter) jjtn000).setCurrentResult(constant.copy());
               }
           }
           jjtn000.setTokenName(name);
        }
    )
 )/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 {
   return t;
 }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

Token Number()         :
{/*@bgen(jjtree) NUMBER */
   SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTNUMBER);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
/*@egen*/
   Token t;
}
{/*@bgen(jjtree) NUMBER */
 try {
/*@egen*/
 (
   t=<NUMBER>
 )/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 {
   jjtn000.setTokenName(t.image);
   return t;
 }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

Token Identifier()             :
{/*@bgen(jjtree) IDENTIFIER */
   SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTIDENTIFIER);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
/*@egen*/
   Token t;
}
{/*@bgen(jjtree) IDENTIFIER */
 try {
/*@egen*/
 (
   t=<IDENTIFIER>
        {
           /**
            * Provided name of identifier, we can search for constant result in variable provider
            */
           String name = t.image;
           if ( getVariableProvider() != null )
           {
               AbstractConstant constant = getVariableProvider().getVariableConstant(name);
               if ( constant != null && (jjtn000 instanceof Variable) )
               {
                   // set current result
                   ((Variable) jjtn000).setCurrentResult(constant.copy());
               }
           }
           jjtn000.setTokenName(name);
        }
 )/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 {
   return t;
 }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

Token Constant()           :
{/*@bgen(jjtree) CONSTANT */
   SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTCONSTANT);
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
/*@egen*/
   Token t;
}
{/*@bgen(jjtree) CONSTANT */
 try {
/*@egen*/
 (
     t=<EXP_E> | t=<PI>
 )/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 {
     jjtn000.setTokenName(t.image);
     jjtn000.setTokenKind(t.kind);
     return t;
 }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void DeltaExpression()             :
{/*@bgen(jjtree) DELTA_EXPR */
    SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTDELTA_EXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) DELTA_EXPR */
   try {
/*@egen*/
   (
       t=<DELTA> {jjtn000.setTokenName(t.image);}
       UnaryExpression()
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void HatExpression()           :
{/*@bgen(jjtree) HAT_EXPR */
    SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTHAT_EXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) HAT_EXPR */
   try {
/*@egen*/
   (
       t=<HAT> {jjtn000.setTokenName(t.image);}
       UnaryExpression()
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void VectorExpression()              :
{/*@bgen(jjtree) VECTOR_EXPR */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTVECTOR_EXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) VECTOR_EXPR */
    try {
/*@egen*/
    "vec" {jjtn000.setTokenName("vec");}
    UnaryExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Function()           :
{/*@bgen(jjtree) FUNCTION */
    SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTFUNCTION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
    StringBuffer signature = new StringBuffer();
}
{/*@bgen(jjtree) FUNCTION */
    try {
/*@egen*/
    (t=<IDENTIFIER>|t=<EXP_E>) { signature.append(t.image); }
    ( (t=<IDENTIFIER>|t=<NUMBER>|t=<EXP_E>) { signature.append(t.image); } )*
    {
        jjtn000.setTokenName(signature.toString());
    }
    <OPEN_BR> Expression() (","  Expression() )* <CLOSE_BR>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}