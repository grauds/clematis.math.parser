/* Generated By:JJTree&JavaCC: Do not edit this line. StringMathParser.java */
package org.clematis.math.parsers.string;

/***************************************************************
 String Mathematics Parser

 This parser built on grammar with following features.

 The precedence of operators is very important. Since this is a
 recursive descent parser, it is easy to see which operators have
 higher order of precedence. The following table outlines the
 order incorporated in this grammar.

 Order of precedence (from lowest to highest):

 +   -            addition, subtraction
 *   /            multiplication, division
 +   -            unary +/-
 ^                power

 Parser supports injection of variable parameters into string maths,
 annotated with $ sign. Parameters may be of following types:

 $a, $a_j12, $acv, ${acv}

 Two last parameter notations are eqivalent, in fact it is not reflected
 by the grammar, but by evaluation procedure.

 Simple variable may be of only one letter: x, y, z, a, b, c.

 Variables and expressions may have indexes: x_2, y_i, z_(k), z_(betta).
 If index contains only one letter it may not have brackets.

 @author Anton Troshin
 ***************************************************************/

import org.clematis.math.AbstractConstant;
import org.clematis.math.FunctionFactory;
import org.clematis.math.SimpleParameter;
import org.clematis.math.Variable;
import org.clematis.math.algorithm.iFunctionProvider;
import org.clematis.math.algorithm.iSimpleParameterProvider;
import org.clematis.math.algorithm.iVariableProvider;
import org.clematis.math.parsers.SimpleNode;
import org.clematis.math.parsers.StringMathParserTreeConstants;

import java.io.StringReader;

/**
 * Class for parsing calculator notation maths.
 */
public class StringMathParser/*@bgen(jjtree)*/
    implements StringMathParserTreeConstants, StringMathParserConstants {/*@bgen(jjtree)*/
    protected JJTStringMathParserState jjtree = new JJTStringMathParserState();
    /**
     * Instance of parameter provider
     */
    private iSimpleParameterProvider parameterProvider = null;
    /**
     * Instance of variable provider
     */
    private iVariableProvider variableProvider = null;
    /**
     * Instance of function provider
     */
    private iFunctionProvider functionProvider = new FunctionFactory();

    /**
     * Parse expression and print to webtex
     */
    public static String printToWebTex(String expr) throws ParseException {
        StringMathParser parser = new StringMathParser(new StringReader(expr));
        SimpleNode n = parser.Start();
        StringBuilder sb = new StringBuilder();
        WebTexPrinter.print(n, sb);
        return sb.toString();
    }

    /**
     * Return an instance of parameter provider
     */
    public iSimpleParameterProvider getParameterProvider() {
        return parameterProvider;
    }

    /**
     * Sets an instance of parameter provider parser
     */
    public void setParameterProvider(iSimpleParameterProvider parameterProvider) {
        this.parameterProvider = parameterProvider;
    }

    /**
     * Return an instance of variable provider
     */
    public iVariableProvider getVariableProvider() {
        return variableProvider;
    }

    /**
     * Sets an instance of variable provider parser
     */
    public void setVariableProvider(iVariableProvider variableProvider) {
        this.variableProvider = variableProvider;
    }

    /**
     * Return an instance of function provider
     */
    public iFunctionProvider getFunctionProvider() {
        return functionProvider;
    }

    /**
     * Sets an instance of function provider parser
     */
    public void setFunctionProvider(iFunctionProvider functionProvider) {
        this.functionProvider = functionProvider;
    }

    /**
     * Returns true if one next token is a function name
     */
    public boolean isFunctionAhead() {
        StringBuffer buffer = new StringBuffer();
        int i = 1;
        if (getToken(1).kind == IDENTIFIER || getToken(1).kind == EXP_E) {
            while (getToken(i).kind == IDENTIFIER ||
                getToken(i).kind == NUMBER || getToken(i).kind == EXP_E) {
                buffer.append(getToken(i).image);
                i++;
                if (functionProvider.hasFunction(buffer.toString())) {
                    return true;
                }
            }
        }
        return false;
    }

    final public SimpleNode Start() throws ParseException {
        if (jj_2_1(1)) {
            SimpleNode jjtn001 = (SimpleNode) SimpleNode.jjtCreate(this, JJTEXPR);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
            try {
                Expression();
                jj_consume_token(0);
                jjtree.closeNodeScope(jjtn001, true);
                jjtc001 = false;
                {
                    if (true) {
                        return jjtn001;
                    }
                }
            } catch (Throwable jjte001) {
                if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                } else {
                    jjtree.popNode();
                }
                if (jjte001 instanceof RuntimeException) {
                    {
                        if (true) {
                            throw (RuntimeException) jjte001;
                        }
                    }
                }
                if (jjte001 instanceof ParseException) {
                    {
                        if (true) {
                            throw (ParseException) jjte001;
                        }
                    }
                }
                {
                    if (true) {
                        throw (Error) jjte001;
                    }
                }
            } finally {
                if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                }
            }
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case 0:
                    jj_consume_token(0);
                {
                    if (true) {
                        throw new ParseException("Empty expression");
                    }
                }
                {
                    if (true) {
                        return null;
                    }
                }
                break;
                default:
                    jj_la1[0] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public void Expression() throws ParseException {
        EqualsExpression();
    }

    final public void EqualsExpression() throws ParseException {
        /*@bgen(jjtree) #EQUALS_EXPR(> 1) */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTEQUALS_EXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        String name = null;
        Token t;
        try {
            PlusExpression();
            label_1:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case EQUALS:
                        break;
                    default:
                        jj_la1[1] = jj_gen;
                        break label_1;
                }
                t = jj_consume_token(EQUALS);
                name = t.image;
                PlusExpression();
            }
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
            jjtc000 = false;
            jjtn000.setTokenName(name);
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) {
                        throw (RuntimeException) jjte000;
                    }
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) {
                        throw (ParseException) jjte000;
                    }
                }
            }
            {
                if (true) {
                    throw (Error) jjte000;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
            }
        }
    }

    final public void PlusExpression() throws ParseException {
        /*@bgen(jjtree) #PLUS_EXPR(> 1) */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTPLUS_EXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            MinusExpression();
            label_2:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case PLUS:
                        break;
                    default:
                        jj_la1[2] = jj_gen;
                        break label_2;
                }
                t = jj_consume_token(PLUS);
                jjtn000.setTokenName(t.image);
                MinusExpression();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) {
                        throw (RuntimeException) jjte000;
                    }
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) {
                        throw (ParseException) jjte000;
                    }
                }
            }
            {
                if (true) {
                    throw (Error) jjte000;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
            }
        }
    }

    final public void MinusExpression() throws ParseException {
        /*@bgen(jjtree) #MINUS_EXPR(> 1) */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTMINUS_EXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            MultExpression();
            label_3:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case MINUS:
                        break;
                    default:
                        jj_la1[3] = jj_gen;
                        break label_3;
                }
                t = jj_consume_token(MINUS);
                jjtn000.setTokenName(t.image);
                MultExpression();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) {
                        throw (RuntimeException) jjte000;
                    }
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) {
                        throw (ParseException) jjte000;
                    }
                }
            }
            {
                if (true) {
                    throw (Error) jjte000;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
            }
        }
    }

    final public void MultExpression() throws ParseException {
        /*@bgen(jjtree) #MULT_EXPR(> 1) */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTMULT_EXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            DivExpressionMinus();
            label_4:
            while (true) {
                if (jj_2_2(1)) {
                } else {
                    break;
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case MULT:
                        t = jj_consume_token(MULT);
                        jjtn000.setTokenName(t.image);
                        DivExpressionMinus();
                        break;
                    default:
                        jj_la1[4] = jj_gen;
                        if (jj_2_3(1)) {
                            jjtn000.setTokenName("*");
                            DivExpression();
                        } else {
                            jj_consume_token(-1);
                            throw new ParseException();
                        }
                }
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) {
                        throw (RuntimeException) jjte000;
                    }
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) {
                        throw (ParseException) jjte000;
                    }
                }
            }
            {
                if (true) {
                    throw (Error) jjte000;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
            }
        }
    }

    //divide expression without unary minus
    final public void DivExpression() throws ParseException {
        /*@bgen(jjtree) #DIV_EXPR(> 1) */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTDIV_EXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            PowerExpression();
            label_5:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case DIV:
                        break;
                    default:
                        jj_la1[5] = jj_gen;
                        break label_5;
                }
                t = jj_consume_token(DIV);
                jjtn000.setTokenName(t.image);
                PowerExpression();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) {
                        throw (RuntimeException) jjte000;
                    }
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) {
                        throw (ParseException) jjte000;
                    }
                }
            }
            {
                if (true) {
                    throw (Error) jjte000;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
            }
        }
    }

    //divide expression with unary minus
    final public void DivExpressionMinus() throws ParseException {
        /*@bgen(jjtree) #DIV_EXPR(> 1) */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTDIV_EXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            NegativeExpr();
            label_6:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case DIV:
                        break;
                    default:
                        jj_la1[6] = jj_gen;
                        break label_6;
                }
                t = jj_consume_token(DIV);
                jjtn000.setTokenName(t.image);
                NegativeExpr();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) {
                        throw (RuntimeException) jjte000;
                    }
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) {
                        throw (ParseException) jjte000;
                    }
                }
            }
            {
                if (true) {
                    throw (Error) jjte000;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
            }
        }
    }

    final public void NegativeExpr() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case MINUS:
                SimpleNode jjtn001 = (SimpleNode) SimpleNode.jjtCreate(this, JJTUNARY_MINUS);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
                try {
                    jj_consume_token(MINUS);
                    PositiveExpr();
                } catch (Throwable jjte001) {
                    if (jjtc001) {
                        jjtree.clearNodeScope(jjtn001);
                        jjtc001 = false;
                    } else {
                        jjtree.popNode();
                    }
                    if (jjte001 instanceof RuntimeException) {
                        {
                            if (true) {
                                throw (RuntimeException) jjte001;
                            }
                        }
                    }
                    if (jjte001 instanceof ParseException) {
                        {
                            if (true) {
                                throw (ParseException) jjte001;
                            }
                        }
                    }
                    {
                        if (true) {
                            throw (Error) jjte001;
                        }
                    }
                } finally {
                    if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001, true);
                    }
                }
                break;
            default:
                jj_la1[7] = jj_gen;
                if (jj_2_4(1)) {
                    PositiveExpr();
                } else {
                    jj_consume_token(-1);
                    throw new ParseException();
                }
        }
    }

    final public void PositiveExpr() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case PLUS:
                SimpleNode jjtn001 = (SimpleNode) SimpleNode.jjtCreate(this, JJTUNARY_PLUS);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
                try {
                    jj_consume_token(PLUS);
                    PowerExpression();
                } catch (Throwable jjte001) {
                    if (jjtc001) {
                        jjtree.clearNodeScope(jjtn001);
                        jjtc001 = false;
                    } else {
                        jjtree.popNode();
                    }
                    if (jjte001 instanceof RuntimeException) {
                        {
                            if (true) {
                                throw (RuntimeException) jjte001;
                            }
                        }
                    }
                    if (jjte001 instanceof ParseException) {
                        {
                            if (true) {
                                throw (ParseException) jjte001;
                            }
                        }
                    }
                    {
                        if (true) {
                            throw (Error) jjte001;
                        }
                    }
                } finally {
                    if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001, true);
                    }
                }
                break;
            default:
                jj_la1[8] = jj_gen;
                if (jj_2_5(1)) {
                    PowerExpression();
                } else {
                    jj_consume_token(-1);
                    throw new ParseException();
                }
        }
    }

    final public void PowerExpression() throws ParseException {
        /*@bgen(jjtree) #POWER_EXPR(> 1) */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTPOWER_EXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            IndexExpression();
            label_7:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case POWER:
                        break;
                    default:
                        jj_la1[9] = jj_gen;
                        break label_7;
                }
                t = jj_consume_token(POWER);
                jjtn000.setTokenName(t.image);
                IndexExpression();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) {
                        throw (RuntimeException) jjte000;
                    }
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) {
                        throw (ParseException) jjte000;
                    }
                }
            }
            {
                if (true) {
                    throw (Error) jjte000;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
            }
        }
    }

    final public void IndexExpression() throws ParseException {
        /*@bgen(jjtree) #INDEX_EXPR(> 1) */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTINDEX_EXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            UnaryExpression();
            label_8:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case UNDERLINE:
                        break;
                    default:
                        jj_la1[10] = jj_gen;
                        break label_8;
                }
                t = jj_consume_token(UNDERLINE);
                jjtn000.setTokenName(t.image);
                Index();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) {
                        throw (RuntimeException) jjte000;
                    }
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) {
                        throw (ParseException) jjte000;
                    }
                }
            }
            {
                if (true) {
                    throw (Error) jjte000;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
            }
        }
    }

    final public void UnaryExpression() throws ParseException {
        if (jj_2_6(1)) {
            if (isFunctionAhead()) {
                Function();
            } else {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case IDENTIFIER:
                        Identifier();
                        break;
                    case EXP_E:
                    case PI:
                        Constant();
                        break;
                    default:
                        jj_la1[11] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
        } else {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case OPEN_BR:
                    jj_consume_token(OPEN_BR);
                    Expression();
                    jj_consume_token(CLOSE_BR);
                    break;
                case VARIABLE:
                    Variable();
                    break;
                case NUMBER:
                    Number();
                    break;
                case 28:
                    VectorExpression();
                    break;
                case DELTA:
                    DeltaExpression();
                    break;
                case HAT:
                    HatExpression();
                    break;
                case STRING:
                    String();
                    break;
                default:
                    jj_la1[12] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }

    final public void Index() throws ParseException {
        /*@bgen(jjtree) INDEX */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTINDEX);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        StringBuffer index = new StringBuffer();
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case OPEN_BR:
                    jj_consume_token(OPEN_BR);
                    label_9:
                    while (true) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case IDENTIFIER:
                                t = jj_consume_token(IDENTIFIER);
                                break;
                            case NUMBER:
                                t = jj_consume_token(NUMBER);
                                break;
                            case EXP_E:
                                t = jj_consume_token(EXP_E);
                                break;
                            default:
                                jj_la1[13] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        index.append(t.image);
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case NUMBER:
                            case IDENTIFIER:
                            case EXP_E:
                                break;
                            default:
                                jj_la1[14] = jj_gen;
                                break label_9;
                        }
                    }
                    jjtn000.setTokenName(index.toString());
                    jj_consume_token(CLOSE_BR);
                    break;
                case IDENTIFIER:
                    Identifier();
                    break;
                case NUMBER:
                    Number();
                    break;
                case EXP_E:
                case PI:
                    Constant();
                    break;
                default:
                    jj_la1[15] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) {
                        throw (RuntimeException) jjte000;
                    }
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) {
                        throw (ParseException) jjte000;
                    }
                }
            }
            {
                if (true) {
                    throw (Error) jjte000;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public Token String() throws ParseException {
        /*@bgen(jjtree) STRING */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTSTRING);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            t = jj_consume_token(STRING);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtn000.setTokenName(t.image);
            {
                if (true) {
                    return t;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public Token Variable() throws ParseException {
        /*@bgen(jjtree) VAR */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTVAR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            t = jj_consume_token(VARIABLE);
            /**
             * Provided name of variable parameter, we can search for constant
             * result in parameter provider
             */
            String name = t.image;
            if (getParameterProvider() != null) {
                AbstractConstant constant = getParameterProvider().getParameterConstant(name);
                if (constant != null && (jjtn000 instanceof SimpleParameter)) {
                    // set current result
                    ((SimpleParameter) jjtn000).setCurrentResult(constant.copy());
                }
            }
            jjtn000.setTokenName(name);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            {
                if (true) {
                    return t;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public Token Number() throws ParseException {
        /*@bgen(jjtree) NUMBER */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTNUMBER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            t = jj_consume_token(NUMBER);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtn000.setTokenName(t.image);
            {
                if (true) {
                    return t;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public Token Identifier() throws ParseException {
        /*@bgen(jjtree) IDENTIFIER */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTIDENTIFIER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            t = jj_consume_token(IDENTIFIER);
            /**
             * Provided name of identifier, we can search for constant result in variable provider
             */
            String name = t.image;
            if (getVariableProvider() != null) {
                AbstractConstant constant = getVariableProvider().getVariableConstant(name);
                if (constant != null && (jjtn000 instanceof Variable)) {
                    // set current result
                    ((Variable) jjtn000).setCurrentResult(constant.copy());
                }
            }
            jjtn000.setTokenName(name);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            {
                if (true) {
                    return t;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public Token Constant() throws ParseException {
        /*@bgen(jjtree) CONSTANT */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTCONSTANT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case EXP_E:
                    t = jj_consume_token(EXP_E);
                    break;
                case PI:
                    t = jj_consume_token(PI);
                    break;
                default:
                    jj_la1[16] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtn000.setTokenName(t.image);
            jjtn000.setTokenKind(t.kind);
            {
                if (true) {
                    return t;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public void DeltaExpression() throws ParseException {
        /*@bgen(jjtree) DELTA_EXPR */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTDELTA_EXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            t = jj_consume_token(DELTA);
            jjtn000.setTokenName(t.image);
            UnaryExpression();
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) {
                        throw (RuntimeException) jjte000;
                    }
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) {
                        throw (ParseException) jjte000;
                    }
                }
            }
            {
                if (true) {
                    throw (Error) jjte000;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public void HatExpression() throws ParseException {
        /*@bgen(jjtree) HAT_EXPR */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTHAT_EXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        try {
            t = jj_consume_token(HAT);
            jjtn000.setTokenName(t.image);
            UnaryExpression();
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) {
                        throw (RuntimeException) jjte000;
                    }
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) {
                        throw (ParseException) jjte000;
                    }
                }
            }
            {
                if (true) {
                    throw (Error) jjte000;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public void VectorExpression() throws ParseException {
        /*@bgen(jjtree) VECTOR_EXPR */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTVECTOR_EXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        try {
            jj_consume_token(28);
            jjtn000.setTokenName("vec");
            UnaryExpression();
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) {
                        throw (RuntimeException) jjte000;
                    }
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) {
                        throw (ParseException) jjte000;
                    }
                }
            }
            {
                if (true) {
                    throw (Error) jjte000;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final public void Function() throws ParseException {
        /*@bgen(jjtree) FUNCTION */
        SimpleNode jjtn000 = (SimpleNode) SimpleNode.jjtCreate(this, JJTFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        Token t;
        StringBuffer signature = new StringBuffer();
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case IDENTIFIER:
                    t = jj_consume_token(IDENTIFIER);
                    break;
                case EXP_E:
                    t = jj_consume_token(EXP_E);
                    break;
                default:
                    jj_la1[17] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            signature.append(t.image);
            label_10:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case NUMBER:
                    case IDENTIFIER:
                    case EXP_E:
                        break;
                    default:
                        jj_la1[18] = jj_gen;
                        break label_10;
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case IDENTIFIER:
                        t = jj_consume_token(IDENTIFIER);
                        break;
                    case NUMBER:
                        t = jj_consume_token(NUMBER);
                        break;
                    case EXP_E:
                        t = jj_consume_token(EXP_E);
                        break;
                    default:
                        jj_la1[19] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                signature.append(t.image);
            }
            jjtn000.setTokenName(signature.toString());
            jj_consume_token(OPEN_BR);
            Expression();
            label_11:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case 29:
                        break;
                    default:
                        jj_la1[20] = jj_gen;
                        break label_11;
                }
                jj_consume_token(29);
                Expression();
            }
            jj_consume_token(CLOSE_BR);
        } catch (Throwable jjte000) {
            if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException) {
                {
                    if (true) {
                        throw (RuntimeException) jjte000;
                    }
                }
            }
            if (jjte000 instanceof ParseException) {
                {
                    if (true) {
                        throw (ParseException) jjte000;
                    }
                }
            }
            {
                if (true) {
                    throw (Error) jjte000;
                }
            }
        } finally {
            if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
            }
        }
    }

    final private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_1();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(0, xla);
        }
    }

    final private boolean jj_2_2(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_2();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(1, xla);
        }
    }

    final private boolean jj_2_3(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_3();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(2, xla);
        }
    }

    final private boolean jj_2_4(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_4();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(3, xla);
        }
    }

    final private boolean jj_2_5(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_5();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(4, xla);
        }
    }

    final private boolean jj_2_6(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_6();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(5, xla);
        }
    }

    final private boolean jj_3R_38() {
        return jj_scan_token(NUMBER);
    }

    final private boolean jj_3R_23() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(11)) {
            jj_scanpos = xsp;
            return jj_scan_token(15);
        }
        return false;
    }

    final private boolean jj_3R_16() {
        return jj_3R_22();
    }

    final private boolean jj_3_1() {
        return jj_3R_12();
    }

    final private boolean jj_3R_21() {
        return jj_scan_token(PLUS);
    }

    final private boolean jj_3R_15() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_21()) {
            jj_scanpos = xsp;
            return jj_3_5();
        }
        return false;
    }

    final private boolean jj_3R_39() {
        return jj_scan_token(28);
    }

    final private boolean jj_3R_45() {
        return jj_scan_token(MINUS);
    }

    final private boolean jj_3R_44() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_45()) {
            jj_scanpos = xsp;
            return jj_3_4();
        }
        return false;
    }

    final private boolean jj_3R_41() {
        return jj_scan_token(HAT);
    }

    final private boolean jj_3_2() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_13()) {
            jj_scanpos = xsp;
            return jj_3_3();
        }
        return false;
    }

    final private boolean jj_3R_13() {
        return jj_scan_token(MULT);
    }

    final private boolean jj_3R_43() {
        return jj_3R_44();
    }

    final private boolean jj_3R_37() {
        return jj_scan_token(VARIABLE);
    }

    final private boolean jj_3R_40() {
        return jj_scan_token(DELTA);
    }

    final private boolean jj_3R_14() {
        return jj_3R_16();
    }

    final private boolean jj_3R_42() {
        return jj_scan_token(STRING);
    }

    final private boolean jj_3_3() {
        return jj_3R_14();
    }

    final private boolean jj_3R_25() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(15)) {
            jj_scanpos = xsp;
            return jj_scan_token(16);
        }
        return false;
    }

    final private boolean jj_3R_36() {
        return jj_3R_43();
    }

    final private boolean jj_3R_28() {
        return jj_3R_36();
    }

    final private boolean jj_3R_35() {
        return jj_3R_42();
    }

    final private boolean jj_3R_34() {
        return jj_3R_41();
    }

    final private boolean jj_3R_33() {
        return jj_3R_40();
    }

    final private boolean jj_3R_32() {
        return jj_3R_39();
    }

    final private boolean jj_3R_31() {
        return jj_3R_38();
    }

    final private boolean jj_3R_19() {
        return jj_3R_25();
    }

    final private boolean jj_3R_30() {
        return jj_3R_37();
    }

    final private boolean jj_3R_26() {
        return jj_3R_28();
    }

    final private boolean jj_3R_29() {
        return jj_scan_token(OPEN_BR);
    }

    final private boolean jj_3R_18() {
        return jj_3R_24();
    }

    final private boolean jj_3R_17() {
        return jj_3R_23();
    }

    final private boolean jj_3_6() {
        Token xsp;
        xsp = jj_scanpos;
        lookingAhead = true;
        jj_semLA = isFunctionAhead();
        lookingAhead = false;
        if (!jj_semLA || jj_3R_17()) {
            jj_scanpos = xsp;
            if (jj_3R_18()) {
                jj_scanpos = xsp;
                return jj_3R_19();
            }
        }
        return false;
    }

    final private boolean jj_3_5() {
        return jj_3R_16();
    }

    final private boolean jj_3R_24() {
        return jj_scan_token(IDENTIFIER);
    }

    final private boolean jj_3R_20() {
        return jj_3R_26();
    }

    final private boolean jj_3R_27() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_6()) {
            jj_scanpos = xsp;
            if (jj_3R_29()) {
                jj_scanpos = xsp;
                if (jj_3R_30()) {
                    jj_scanpos = xsp;
                    if (jj_3R_31()) {
                        jj_scanpos = xsp;
                        if (jj_3R_32()) {
                            jj_scanpos = xsp;
                            if (jj_3R_33()) {
                                jj_scanpos = xsp;
                                if (jj_3R_34()) {
                                    jj_scanpos = xsp;
                                    return jj_3R_35();
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    final private boolean jj_3_4() {
        return jj_3R_15();
    }

    final private boolean jj_3R_22() {
        return jj_3R_27();
    }

    final private boolean jj_3R_12() {
        return jj_3R_20();
    }

    public StringMathParserTokenManager token_source;
    SimpleCharStream jj_input_stream;
    public Token token, jj_nt;
    private int jj_ntk;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    public boolean lookingAhead = false;
    private boolean jj_semLA;
    private int jj_gen;
    final private int[] jj_la1 = new int[21];
    static private int[] jj_la1_0;

    static {
        jj_la1_0();
    }

    private static void jj_la1_0() {
        jj_la1_0 = new int[]{0x1, 0x200000, 0x80000, 0x100000, 0x20000, 0x40000, 0x40000, 0x100000, 0x80000, 0x400000,
            0x8000000, 0x18800, 0x13806080, 0x8880, 0x8880, 0x2018880, 0x18000, 0x8800, 0x8880, 0x8880, 0x20000000,};
    }

    final private JJCalls[] jj_2_rtns = new JJCalls[6];
    private boolean jj_rescan = false;
    private int jj_gc = 0;

    public StringMathParser(java.io.InputStream stream) {
        this(stream, null);
    }

    public StringMathParser(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new StringMathParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 21; i++) {
            jj_la1[i] = -1;
        }
        for (int i = 0; i < jj_2_rtns.length; i++) {
            jj_2_rtns[i] = new JJCalls();
        }
    }

    public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }

    public void ReInit(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 21; i++) {
            jj_la1[i] = -1;
        }
        for (int i = 0; i < jj_2_rtns.length; i++) {
            jj_2_rtns[i] = new JJCalls();
        }
    }

    public StringMathParser(java.io.Reader stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new StringMathParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 21; i++) {
            jj_la1[i] = -1;
        }
        for (int i = 0; i < jj_2_rtns.length; i++) {
            jj_2_rtns[i] = new JJCalls();
        }
    }

    public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 21; i++) {
            jj_la1[i] = -1;
        }
        for (int i = 0; i < jj_2_rtns.length; i++) {
            jj_2_rtns[i] = new JJCalls();
        }
    }

    public StringMathParser(StringMathParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 21; i++) {
            jj_la1[i] = -1;
        }
        for (int i = 0; i < jj_2_rtns.length; i++) {
            jj_2_rtns[i] = new JJCalls();
        }
    }

    public void ReInit(StringMathParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 21; i++) {
            jj_la1[i] = -1;
        }
        for (int i = 0; i < jj_2_rtns.length; i++) {
            jj_2_rtns[i] = new JJCalls();
        }
    }

    final private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) {
            token = token.next;
        } else {
            token = token.next = token_source.getNextToken();
        }
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null) {
                        if (c.gen < jj_gen) {
                            c.first = null;
                        }
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    static private final class LookaheadSuccess extends java.lang.Error {
    }

    final private LookaheadSuccess jj_ls = new LookaheadSuccess();

    final private boolean jj_scan_token(int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null) {
                jj_add_error_token(kind, i);
            }
        }
        if (jj_scanpos.kind != kind) {
            return true;
        }
        if (jj_la == 0 && jj_scanpos == jj_lastpos) {
            throw jj_ls;
        }
        return false;
    }

    final public Token getNextToken() {
        if (token.next != null) {
            token = token.next;
        } else {
            token = token.next = token_source.getNextToken();
        }
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    final public Token getToken(int index) {
        Token t = lookingAhead ? jj_scanpos : token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) {
                t = t.next;
            } else {
                t = t.next = token_source.getNextToken();
            }
        }
        return t;
    }

    final private int jj_ntk() {
        if ((jj_nt = token.next) == null) {
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        } else {
            return (jj_ntk = jj_nt.kind);
        }
    }

    private final java.util.Vector jj_expentries = new java.util.Vector();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private final int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void jj_add_error_token(int kind, int pos) {
        if (pos >= 100) {
            return;
        }
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            System.arraycopy(jj_lasttokens, 0, jj_expentry, 0, jj_endpos);
            boolean exists = false;
            for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements(); ) {
                int[] oldentry = (int[]) (e.nextElement());
                if (oldentry.length == jj_expentry.length) {
                    exists = true;
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            exists = false;
                            break;
                        }
                    }
                    if (exists) {
                        break;
                    }
                }
            }
            if (!exists) {
                jj_expentries.addElement(jj_expentry);
            }
            if (pos != 0) {
                jj_lasttokens[(jj_endpos = pos) - 1] = kind;
            }
        }
    }

    public ParseException generateParseException() {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[30];
        for (int i = 0; i < 30; i++) {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 21; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 30; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[]) jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    final public void enable_tracing() {
    }

    final public void disable_tracing() {
    }

    final private void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 6; i++) {
            try {
                JJCalls p = jj_2_rtns[i];
                do {
                    if (p.gen > jj_gen) {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i) {
                            case 0:
                                jj_3_1();
                                break;
                            case 1:
                                jj_3_2();
                                break;
                            case 2:
                                jj_3_3();
                                break;
                            case 3:
                                jj_3_4();
                                break;
                            case 4:
                                jj_3_5();
                                break;
                            case 5:
                                jj_3_6();
                                break;
                        }
                    }
                    p = p.next;
                } while (p != null);
            } catch (LookaheadSuccess ls) {
            }
        }
        jj_rescan = false;
    }

    final private void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static final class JJCalls {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
